Uses websockets and JSON. WIP.

--> send to server
<-- receive from server

=== Movement on the map ===
--> MOV {"from": [x1,y1], "to": [x2,y2], "dir": 0}
move yourself

--> MOV {"dir": 0}
change direction only

<-- MOV {"from": [x1,y1], "to": [x2,y2], "dir": 0, "id": 0}
move a player on the map.
"from" may be left out, and if so, a client won't ignore MOVs for its own ID.

--> TAP {"pos": [x,y]}
sent by an attempt to move into a dense object.
can be triggered by clicking too
(not implemented)

=== Map contents ===
--> PUT {"pos": [x,y], "atom": {atom}}
<-- PUT {"pos": [x,y], "atom": {atom}, "username": username, "remote_map": map} (for listeners)
<-- MAP {updated map}
place a tile on the map
can use string instead of atom definition if it's predefined

--> MAP - requests the whole thing
--> MAP {"pos":[x1, y1, x2, y2]}
<-- MAP {"pos":[x1, y1, x2, y2], "default": default_turf, "turf": [turfs], "obj": [objs]}
get a partial (or complete) copy of the map
(currently server-->client only)

--> MAI
<-- MAI {"name": map_name, "id": map_id, "owner": whoever, "admins": list, "default": default_turf, "size": [width, height], "public": true/false, "private": true/false, "build_enabled": true/false, "full_sandbox": true/false, "you_allow": list, "you_deny": list}
map info stuff.
Optionally also defines "entry_whitelist", "entry_banlist" and "start_pos" for map admins

--> DEL {"pos": [x1, y1, x2, y2], "turf":true, "obj":true}
<-- DEL {"pos": [x1, y1, x2, y2], "turf":true, "obj":true, "username":username, "remote_map": map} (for listeners)
<-- MAP {updated map}
delete a section of map

--> BLK {"turf": [[x, y, type, w, h], ...], "obj": [[x, y, [type], w, h], ...]}
<-- BLK {"turf": [[x, y, type, w, h], ...], "obj": [[x, y, [type], w, h], ...], "username": username}
bulk building command. width and height may be omitted.
applies a series of rectangles to the map.


=== Resources ===
--> IMG {"id": number}
request an image asset's URL

<-- IMG {"id": number, "url": string}
have the client load an image, for tilesets or avatars or other purposes

--> TSD {"id": number}
request tileset data from the server

<-- TSD {"id": number, "data": [id, info, id, info, id, info, ...]}
tileset received from the server


=== People on the map ===
--> WHO
--> WHO {"update": {"id": your_id, other fields}}
<-- WHO {"list": {"[id]": {"name": name, "pic": [s, x, y], "x": x, "y": y, "dir": dir, "id": id}, "you":id}
<-- WHO {"add": {"name": name, "pic": [s, x, y], "x": x, "y": y, "dir", dir, "id": id}}
<-- WHO {"update": {"id": id, other fields}}
<-- WHO {"remove": id}
<-- WHO {"new_id": {"id": old_id, "new_id", id}}
"add" can be used to do an update too, where it will replace a whole entry with new data.
"update" can be used for partial updates, where only the fields present in the message are updated and other fields are left alone.
"remove" requests that a specific item be removed.
"new_id" is mostly used when a temporary object gets saved to the database, 

Clients can send updates about themselves, but only keys that the servers knows to be OK, such as "typing".
For client-to-server WHO updates, "id" is currently ignored, but it should be the same value the client received in the "you" field.

--> IDN
--> IDN {"username": username, "password": password}
log into the server with or without an account


=== Misellaneous ===
--> MSG {"text": "[text]"}
message

--> CMD {"text": "[text]", "echo": value, "rc": id}
<-- CMD {"text": "[text]", "echo": value, "data": {}}
Do a command.
"echo" is optional, and will be returned in the response, if there is one.
Command may have a machine-readable response if "echo" is provided, provided in "data".

If "rc" is supplied, the server will act as if the entity specified in the ID did the command instead, returning the command results to you instead.
For "rc", you need to either be the owner or have "remote_command" permissions on the object.

<-- MSG {"text": "[text]", "name": speaker, "class": classname, "username": username}
<-- MSG {"text": "[text]", "name": speaker, "class": classname, "buttons": ["name 1", "command 1", "name 2", "command 2"]}
display message in log.
"class" is a CSS class to style the image with.
"buttons" provides a list of choices to present that will execute commands.

<-- PRI {"text": "[text"], "name": display name, "username": username, "receive": true/false}
private message, displays in the log
receive is false for sender, true for recipient

--> EML {"send": {"subject": subject, "contents": contents, "to": [username, ...]}}
--> EML {"read": id}
--> EML {"delete": id}
send mail or manipulate your inbox

<-- EML {"receive": {"id": id, "subject": subject, "contents": contents, "to": [username, ...], "from": username, "flags": flags}}
<-- EML {"list": [{"id": id, "subject": subject, "contents": contents, "to": [username, ...], "from": username, "flags": flags}]}
<-- EML {"sent": {"subject", subject}}
receive mail from someone, or get a list upon logging in. "sent" acknowledges mail was successfully sent

<-- ERR {"text": "[text]"}
error, maybe include the command that failed?

--> PIN
<-- PIN
ping, if you don't respond fast enough you disconnect

--> VER {"name": client_name, "version":1.0, "code": "https://github.com/NovaSquirrel/TilemapTown"}
<-- VER {"name": server_name, "version":1.0, "code": "https://github.com/NovaSquirrel/TilemapTown"}
version information for client and server
(not implemented)

<-- CFG {"resource": "novasquirrel.com/town/resources"}
resources link?
(not implemented)

=== Items ===
--> MOV {"from": [x1,y1], "to": [x2,y2], "dir": 0, "rc": 0}
<-- MOV {"from": [x1,y1], "to": [x2,y2], "dir": 0, "rc": 0}
Move something else within the same container as you, if you are allowed to

--> USE {"id": id}
Use item
(not implemented)


--> BAG {"create": {"name": name, "type": type}}
--> BAG {"create": {"name": name, "type": type, "temp": true/false}}
Create a new item of a given type
Can create a temporary object instead if you like

--> BAG {"update": {"id": id, "name": name, "desc": desc, "flags": flags, "folder": folder, "data": data, "allow": allow, "deny": deny, "guest_deny": deny, "tags": tags, ...}}
Update one specific item

--> BAG {"move": {"id": id, "folder": map, "pos": [x,y]}}
Moves an entity to another position. "pos" is optional.

--> BAG {"delete": {"id": id}}
Delete an item

--> BAG {"kick": {"id": id}}
Send an entity to its home

--> BAG {"clone": {"id": id}}
--> BAG {"clone": {"id": id}, "temp": true/false}
Make an exact clone of an item with a new ID.
Can make the new object temporary or non-temporary regardless of if the original object was.

--> BAG {"info": {"id": id}}
Request information on an item, whether or not it's in your inventory.

--> BAG {"list_contents": {"id": id}}
Get a BAG "list" in return for the container you picked, if you have permission.

<-- BAG {"info": {"id": id, ...}}
Information about an item somewhere. Message doesn't add the item to a container client-side.

<-- BAG {"update": {item info}}
<-- BAG {"list": [{item info}], "container": id, "clear": false}
Receive an item or list of items from the server. Lists don't replace the client-side list, unless "clear" is specified.
"container" specifies that the items are for a specific ID; otherwise it's assume it's the player than the player.
"clear" specifies that the client-side inventory list for this container should be cleared before adding these.

<-- BAG {"new_id": {"id": old_id, "new_id": id}}
Update the ID of one item in the player's inventory

<-- BAG {"remove": {"id": id}}
Remove one item from the inventory

Item info fields:
(Used for "update", "list", and "info")
	id
	name
	desc
	type
	flags
	folder
	data
	tags
