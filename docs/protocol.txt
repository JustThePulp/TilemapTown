Uses websockets and JSON. WIP.

--> send to server
<-- receive from server

List of entity types:
	user        An entity controlled by a client.
	map         A map.
	group       A user group.
	text        Holds any amount of text, like Second Life's notecards.
	image       Currently just holds a URL to an image, which can be used as a tileset for map tiles and entities.
	map_tile    A template for a tile that can be placed on a map.
	tileset		Holds a series of map tiles. Stored as a JSON array that alternates between names and map tile definitions.
	            Map tiles can reference this tileset with tileset_id:name_of_tile.
	reference   A reference to another entity. Interacting with it should redirect to the entity it points at.
	folder      Holds other entities. Any entity can hold other entities, so this is more of a UI hint.
	landmark    Holds a location, allowing a user to teleport to it easily.
	generic     No special behavior.

List of permissions:
	build                       user can build on the map
	sandbox                     users can delete any part of the map freely (or kick any item from a container)
	admin                       user is an admin on the map
	copy                        user can make copies of this object
	map_bot                     user is given bot-related permissions (like the ability to use /listen)
	move                        user can move this object around within the same container
	move_new_map                user can move this object to a new map
	bulk_build                  user can use the builk building protocol commands
	object_entry                user can bring non-client entities here
	persistent_object_entry     user can bring non-client entities here persistently (will kick clients out when unloading if not true)
	modify_properties           user can modify the properties of this entity
	remote_command              user can make this entity do arbitrary commands
	modify_appearance           user can modify visual properties, like picture or description
	list_contents               user can look at the contents of this entity
	all							shorthand for assigning all permissions

=== Movement on the map ===
--> MOV {"from": [x1,y1], "to": [x2,y2], "dir": 0}
move yourself

--> MOV {"dir": 0}
change direction only

<-- MOV {"from": [x1,y1], "to": [x2,y2], "dir": 0, "id": 0}
move a player on the map.
"from" may be left out, and if so, a client won't ignore MOVs for its own ID.

--> TAP {"pos": [x,y]}
sent by an attempt to move into a dense object.
can be triggered by clicking too
(not implemented)

=== Map contents ===
--> PUT {"pos": [x,y], "atom": {atom}}
<-- PUT {"pos": [x,y], "atom": {atom}, "username": username, "remote_map": map} (for listeners)
<-- MAP {updated map}
place a tile on the map
can use string instead of atom definition if it's predefined

--> MAP - requests the whole thing
--> MAP {"pos":[x1, y1, x2, y2]}
<-- MAP {"pos":[x1, y1, x2, y2], "default": default_turf, "turf": [turfs], "obj": [objs]}
get a partial (or complete) copy of the map
(currently server-->client only)

--> MAI
<-- MAI {"name": map_name, "id": map_id, "owner": whoever, "admins": list, "default": default_turf, "size": [width, height], "public": true/false, "private": true/false, "build_enabled": true/false, "full_sandbox": true/false, "you_allow": list, "you_deny": list}
map info stuff.
Optionally also defines "entry_whitelist", "entry_banlist" and "start_pos" for map admins

--> DEL {"pos": [x1, y1, x2, y2], "turf":true, "obj":true}
<-- DEL {"pos": [x1, y1, x2, y2], "turf":true, "obj":true, "username":username, "remote_map": map} (for listeners)
<-- MAP {updated map}
delete a section of map

--> BLK {"turf": [[x, y, type, w, h], ...], "obj": [[x, y, [type], w, h], ...]}
<-- BLK {"turf": [[x, y, type, w, h], ...], "obj": [[x, y, [type], w, h], ...], "username": username}
Bulk building command. Requires the "bulk_build" permission.
Applies a series of rectangles to the map.
Width and height may be omitted, in order to just do a single tile.

--> BLK {"copy": [{"turf": true/false, "obj": true/false, "src":[x,y,w,h], "dst":[x,y]}, ...]]}
Copies from one portion of the map to another, with overlapped rectangles allowed and supported.
If "turf" and "obj" are also provided in the same BLK message, "copy" is applied first, then "turf" and finally "obj".
This makes it easy to move something by copying it somewhere else and erasing the tile where it was.

=== Resources ===
--> IMG {"id": number}
request an image asset's URL

<-- IMG {"id": number, "url": string}
have the client load an image, for tilesets or avatars or other purposes

--> TSD {"id": number}
request tileset data from the server

<-- TSD {"id": number, "data": "[id, info, id, info, id, info, ...]"}
Tileset received from the server
Received data is in string format, and must be parsed as JSON!

=== People on the map ===
--> WHO
--> WHO {"update": {"id": your_id, other fields}}
<-- WHO {"list": {"[id]": {"name": name, "pic": [s, x, y], "x": x, "y": y, "dir": dir, "id": id}, "you":id}
<-- WHO {"add": {"name": name, "pic": [s, x, y], "x": x, "y": y, "dir", dir, "id": id}}
<-- WHO {"update": {"id": id, other fields}}
<-- WHO {"remove": id}
<-- WHO {"new_id": {"id": old_id, "new_id", id}}
"add" can be used to do an update too, where it will replace a whole entry with new data.
"update" can be used for partial updates, where only the fields present in the message are updated and other fields are left alone.
"remove" requests that a specific item be removed.
"new_id" is mostly used when a temporary object gets saved to the database, 

Clients can send updates about themselves, but only keys that the servers knows to be OK, such as "typing".
For client-to-server WHO updates, "id" is currently ignored, but it should be the same value the client received in the "you" field.

--> IDN
--> IDN {"username": username, "password": password}
log into the server with or without an account


=== Misellaneous ===
--> MSG {"text": "[text]"}
message

--> CMD {"text": "[text]", "echo": value, "rc": id}
<-- CMD {"text": "[text]", "echo": value, "data": {}}
Do a command.
"echo" is optional, and will be returned in the response, if there is one.
Command may have a machine-readable response if "echo" is provided, provided in "data".

If "rc" is supplied, the server will act as if the entity specified in the ID did the command instead, returning the command results to you instead.
For "rc", you need to either be the owner or have "remote_command" permissions on the object.

<-- MSG {"text": "[text]", "name": speaker, "class": classname, "username": username}
<-- MSG {"text": "[text]", "name": speaker, "class": classname, "buttons": ["name 1", "command 1", "name 2", "command 2"]}
display message in log.
"class" is a CSS class to style the image with.
"buttons" provides a list of choices to present that will execute commands.

<-- PRI {"text": "[text"], "name": display name, "username": username, "receive": true/false}
private message, displays in the log
receive is false for sender, true for recipient

--> EML {"send": {"subject": subject, "contents": contents, "to": [username, ...]}}
--> EML {"read": id}
--> EML {"delete": id}
send mail or manipulate your inbox

<-- EML {"receive": {"id": id, "subject": subject, "contents": contents, "to": [username, ...], "from": username, "flags": flags}}
<-- EML {"list": [{"id": id, "subject": subject, "contents": contents, "to": [username, ...], "from": username, "flags": flags}]}
<-- EML {"sent": {"subject", subject}}
receive mail from someone, or get a list upon logging in. "sent" acknowledges mail was successfully sent

<-- ERR {"text": "[text]"}
error, maybe include the command that failed?

--> PIN
<-- PIN
ping, if you don't respond fast enough you disconnect

--> VER {"name": client_name, "version":1.0, "code": "https://github.com/NovaSquirrel/TilemapTown"}
<-- VER {"name": server_name, "version":1.0, "code": "https://github.com/NovaSquirrel/TilemapTown"}
version information for client and server
(not implemented)

<-- RSC {"images": {"id": "url", ...}, "tilesets": {"id": {}, ...}}
Resources for the client to preload.
Allows servers to explicitly provide tilesets, both to allow for custom ones and to make it so that clients don't need to include a copy of the default tilesets.

=== Items ===
--> MOV {"from": [x1,y1], "to": [x2,y2], "dir": 0, "rc": 0}
<-- MOV {"from": [x1,y1], "to": [x2,y2], "dir": 0, "rc": 0}
Move something else within the same container as you, if you are allowed to

--> USE {"id": id}
Use item
(not implemented)


--> BAG {"create": {"name": name, "type": type}}
--> BAG {"create": {"name": name, "type": type, "temp": true/false}}
Create a new item of a given type
Can create a temporary object instead if you like

--> BAG {"update": {"id": id, "name": name, "desc": desc, "flags": flags, "folder": folder, "data": data, "allow": allow, "deny": deny, "guest_deny": deny, "tags": tags, ...}}
Update one specific item.
Allow, deny, and guest_deny are sent as a list of strings, using the permission names earlier in this file.

--> BAG {"move": {"id": id, "folder": map, "pos": [x,y]}}
Moves an entity to another position. "pos" is optional.

--> BAG {"delete": {"id": id}}
Delete an item

--> BAG {"kick": {"id": id}}
Send an entity to its home

--> BAG {"clone": {"id": id}}
--> BAG {"clone": {"id": id}, "temp": true/false}
Make an exact clone of an item with a new ID.
Can make the new object temporary or non-temporary regardless of if the original object was.

--> BAG {"info": {"id": id}}
Request information on an item, whether or not it's in your inventory.

--> BAG {"list_contents": {"id": id}}
Get a BAG "list" in return for the container you picked, if you have permission.

<-- BAG {"info": {"id": id, ...}}
Information about an item somewhere. Message doesn't add the item to a container client-side.

<-- BAG {"update": {item info}}
<-- BAG {"list": [{item info}], "container": id, "clear": false}
Receive an item or list of items from the server. Lists don't replace the client-side list, unless "clear" is specified.
"container" specifies that the items are for a specific ID; otherwise it's assume it's the player than the player.
"clear" specifies that the client-side inventory list for this container should be cleared before adding these.

<-- BAG {"new_id": {"id": old_id, "new_id": id}}
Update the ID of one item in the player's inventory

<-- BAG {"remove": {"id": id}}
Remove one item from the inventory

Item info fields:
(Used for "update", "list", and "info")
	id
	name
	desc
	type
	flags
	folder
	data
	tags
	allow (list of strings, using the permission names at the start of the file)
	deny
	guest_deny
	owner_id
	owner_username (if applicable)
	username (if applicable)
	temporary
